
import { Router } from "express";
import { getSkillsDir, getStateDir } from "../lib/config.js";
import { writeFile, readFile, mkdir } from "fs/promises";
import path from "path";
import { existsSync } from "fs";

export const approvalRoutes = Router();

interface ApprovalConfig {
    groups: {
        intake: string;
        gm: string;
        ceo: string;
        publish: string[];
        logs?: string;
    };
    roles: {
        designers: string[];
        gms: string[];
        ceos: string[];
    };
    triggers: {
        newRequest: string[]; // e.g., ["#approve", "Ø§Ø¹ØªÙ…Ø§Ø¯"]
        approve: string[];    // ["approve", "âœ…"]
        reject: string[];     // ["reject", "âŒ"]
        changes: string[];    // ["changes", "ØªØ¹Ø¯ÙŠÙ„"]
    };
    rules: {
        requireMedia: boolean;
        allowVideo: boolean;
    };
}

const DEFAULT_CONFIG: ApprovalConfig = {
    groups: { intake: "", gm: "", ceo: "", publish: [] },
    roles: { designers: [], gms: [], ceos: [] },
    triggers: {
        newRequest: ["#approve", "Ø§Ø¹ØªÙ…Ø§Ø¯"],
        approve: ["approve", "âœ…", "yes"],
        reject: ["reject", "âŒ", "no"],
        changes: ["changes", "edit", "ØªØ¹Ø¯ÙŠÙ„"],
    },
    rules: { requireMedia: true, allowVideo: false },
};

async function getConfigFile() {
    const stateDir = await getStateDir();
    return path.join(stateDir, "approval-workflow.json");
}

// GET /api/approval/config
approvalRoutes.get("/config", async (_req, res) => {
    try {
        const file = await getConfigFile();
        if (!existsSync(file)) return res.json(DEFAULT_CONFIG);
        const data = await readFile(file, "utf-8");
        res.json(JSON.parse(data));
    } catch (e: any) {
        res.status(500).json({ error: e.message });
    }
});

// POST /api/approval/config (Save & Generate Skill)
approvalRoutes.post("/config", async (req, res) => {
    try {
        const config: ApprovalConfig = req.body;
        const file = await getConfigFile();

        // 1. Save Config JSON
        await writeFile(file, JSON.stringify(config, null, 2), "utf-8");

        // 2. Generate Skill Code
        const skillCode = generateSkillCode(config);
        const skillsDir = await getSkillsDir();
        await mkdir(skillsDir, { recursive: true });
        await writeFile(path.join(skillsDir, "whatsapp-approval.ts"), skillCode, "utf-8");

        res.json({ ok: true, message: "Workflow saved & skill generated!" });
    } catch (e: any) {
        res.status(500).json({ error: e.message });
    }
});

function generateSkillCode(config: ApprovalConfig): string {
    return `
/**
 * WhatsApp Approval Workflow
 * Generated by OpenClaw Dashboard
 */

module.exports = class WhatsAppApprovalWorkflow {
    name = "WhatsApp Approval Workflow";
    description = "Design approval pipeline: Designer -> GM -> CEO -> Publish";
    
    // Define triggers based on configured keywords. Adding #id for helper.
    triggers = ${JSON.stringify([...config.triggers.newRequest, ...config.triggers.approve, ...config.triggers.reject, ...config.triggers.changes, "#id", "#chatid"])};

    // Configuration injected from Dashboard
    config = ${JSON.stringify(config, null, 4)};

    // State management (mock DB for now, ideally use OpenClaw memory)
    requests = new Map(); 

    async execute(context) {
        const { message, sender, group } = context;
        let text = message.text?.toLowerCase() || "";
        const hasMedia = message.image || message.video || message.document;

        // 0. Helper Command: #id
        if (text === "#id" || text === "#chatid") {
             const groupId = group || "Direct Message";
             const reply = \`ðŸ†” **Configuration Helper**\\n\\nðŸ“‚ Group ID: \` + groupId + \`\\nðŸ‘¤ Your ID: \` + sender;
             // Send back to where it came from
             return context.send(groupId, reply);
        }

        // 1. Handle New Request (Intake)
        if (this.isNewRequest(text)) {
            if (!this.isDesigner(sender)) return context.reply("â›” Not authorized to submit designs.");
            if (this.config.rules.requireMedia && !hasMedia) return context.reply("âš ï¸ Media required for approval request.");

            const reqId = "DR-" + Date.now().toString().slice(-6);
             this.requests.set(reqId, {
                id: reqId,
                designer: sender,
                status: "pending_gm",
                media: message.image || message.video, // simplified
                caption: message.caption || text,
                history: [{ stage: "intake", time: Date.now(), by: sender }]
            });

            // Notify GM Group
            if (this.config.groups.gm) {
                await context.send(this.config.groups.gm, \`ðŸ†• *New Design Request* \\nðŸ†”: \${reqId}\\nðŸ‘¤: \${sender}\\n\\nReply with 'approve' or 'reject'\`);
                if (hasMedia) await context.forward(this.config.groups.gm); 
            }
            
            return context.reply(\`âœ… Request \${reqId} submitted for GM approval.\`);
        }

        // 2. Handle Approvals (GM / CEO)
        if (this.isApprove(text)) {
             // Simulation logic
             return context.reply("âœ… Approved (Simulation)");
        }
        
        if (this.isReject(text)) {
             return context.reply("âŒ Rejected (Simulation)");
        }
    }

    isNewRequest(text) {
        return this.config.triggers.newRequest.some(t => text.includes(t));
    }

    isApprove(text) {
        return this.config.triggers.approve.some(t => text.includes(t));
    }

    isReject(text) {
        return this.config.triggers.reject.some(t => text.includes(t));
    }

    isDesigner(sender) {
        // If list is empty, allow all. Otherwise check list.
        if (!this.config.roles.designers || this.config.roles.designers.length === 0) return true;
        return this.config.roles.designers.includes(sender);
    }
};
`;
}
